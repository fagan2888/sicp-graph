<span id="chap_Temp_1"></span>

<div class="chapterheading">

Contents {.chapter}
========

</div>

<span id="%_toc_start"></span>

<div>

<span id="%_toc_start"></span><span
id="%_toc_start"></span>[Foreword](book-Z-H-5.html#%_chap_Temp_2)

</div>

<div>

[Preface to the Second Edition](book-Z-H-6.html#%_chap_Temp_3)

</div>

<div>

[Preface to the First Edition](book-Z-H-7.html#%_chap_Temp_4)

</div>

<div>

[Acknowledgments](book-Z-H-8.html#%_chap_Temp_5)

</div>

------------------------------------------------------------------------

### [1  Building Abstractions with Procedures](book-Z-H-9.html#%_chap_1)

[1.1  The Elements of Programming](book-Z-H-10.html#%_sec_1.1)

[1.1.1  Expressions](book-Z-H-10.html#%_sec_1.1.1)

[1.1.2  Naming and the Environment](book-Z-H-10.html#%_sec_1.1.2)

[1.1.3  Evaluating Combinations](book-Z-H-10.html#%_sec_1.1.3)

[1.1.4  Compound Procedures](book-Z-H-10.html#%_sec_1.1.4)

[1.1.5  The Substitution Model for Procedure
Application](book-Z-H-10.html#%_sec_1.1.5)

[1.1.6  Conditional Expressions and
Predicates](book-Z-H-10.html#%_sec_1.1.6)

[1.1.7  Example: Square Roots by Newton’s
Method](book-Z-H-10.html#%_sec_1.1.7)

[1.1.8  Procedures as Black-Box
Abstractions](book-Z-H-10.html#%_sec_1.1.8)

[1.2  Procedures and the Processes They
Generate](book-Z-H-11.html#%_sec_1.2)

[1.2.1  Linear Recursion and Iteration](book-Z-H-11.html#%_sec_1.2.1)

[1.2.2  Tree Recursion](book-Z-H-11.html#%_sec_1.2.2)

[1.2.3  Orders of Growth](book-Z-H-11.html#%_sec_1.2.3)

[1.2.4  Exponentiation](book-Z-H-11.html#%_sec_1.2.4)

[1.2.5  Greatest Common Divisors](book-Z-H-11.html#%_sec_1.2.5)

[1.2.6  Example: Testing for Primality](book-Z-H-11.html#%_sec_1.2.6)

[1.3  Formulating Abstractions with Higher-Order
Procedures](book-Z-H-12.html#%_sec_1.3)

[1.3.1  Procedures as Arguments](book-Z-H-12.html#%_sec_1.3.1)

[1.3.2  Constructing Procedures Using
`Lambda`](book-Z-H-12.html#%_sec_1.3.2)

[1.3.3  Procedures as General Methods](book-Z-H-12.html#%_sec_1.3.3)

[1.3.4  Procedures as Returned Values](book-Z-H-12.html#%_sec_1.3.4)

### [2  Building Abstractions with Data](book-Z-H-13.html#%_chap_2)

[2.1  Introduction to Data Abstraction](book-Z-H-14.html#%_sec_2.1)

[2.1.1  Example: Arithmetic Operations for Rational
Numbers](book-Z-H-14.html#%_sec_2.1.1)

[2.1.2  Abstraction Barriers](book-Z-H-14.html#%_sec_2.1.2)

[2.1.3  What Is Meant by Data?](book-Z-H-14.html#%_sec_2.1.3)

[2.1.4  Extended Exercise: Interval
Arithmetic](book-Z-H-14.html#%_sec_2.1.4)

[2.2  Hierarchical Data and the Closure
Property](book-Z-H-15.html#%_sec_2.2)

[2.2.1  Representing Sequences](book-Z-H-15.html#%_sec_2.2.1)

[2.2.2  Hierarchical Structures](book-Z-H-15.html#%_sec_2.2.2)

[2.2.3  Sequences as Conventional
Interfaces](book-Z-H-15.html#%_sec_2.2.3)

[2.2.4  Example: A Picture Language](book-Z-H-15.html#%_sec_2.2.4)

[2.3  Symbolic Data](book-Z-H-16.html#%_sec_2.3)

[2.3.1  Quotation](book-Z-H-16.html#%_sec_2.3.1)

[2.3.2  Example: Symbolic Differentiation](book-Z-H-16.html#%_sec_2.3.2)

[2.3.3  Example: Representing Sets](book-Z-H-16.html#%_sec_2.3.3)

[2.3.4  Example: Huffman Encoding Trees](book-Z-H-16.html#%_sec_2.3.4)

[2.4  Multiple Representations for Abstract
Data](book-Z-H-17.html#%_sec_2.4)

[2.4.1  Representations for Complex
Numbers](book-Z-H-17.html#%_sec_2.4.1)

[2.4.2  Tagged data](book-Z-H-17.html#%_sec_2.4.2)

[2.4.3  Data-Directed Programming and
Additivity](book-Z-H-17.html#%_sec_2.4.3)

[2.5  Systems with Generic Operations](book-Z-H-18.html#%_sec_2.5)

[2.5.1  Generic Arithmetic Operations](book-Z-H-18.html#%_sec_2.5.1)

[2.5.2  Combining Data of Different Types](book-Z-H-18.html#%_sec_2.5.2)

[2.5.3  Example: Symbolic Algebra](book-Z-H-18.html#%_sec_2.5.3)

### [3  Modularity, Objects, and State](book-Z-H-19.html#%_chap_3)

[3.1  Assignment and Local State](book-Z-H-20.html#%_sec_3.1)

[3.1.1  Local State Variables](book-Z-H-20.html#%_sec_3.1.1)

[3.1.2  The Benefits of Introducing
Assignment](book-Z-H-20.html#%_sec_3.1.2)

[3.1.3  The Costs of Introducing
Assignment](book-Z-H-20.html#%_sec_3.1.3)

[3.2  The Environment Model of Evaluation](book-Z-H-21.html#%_sec_3.2)

[3.2.1  The Rules for Evaluation](book-Z-H-21.html#%_sec_3.2.1)

[3.2.2  Applying Simple Procedures](book-Z-H-21.html#%_sec_3.2.2)

[3.2.3  Frames as the Repository of Local
State](book-Z-H-21.html#%_sec_3.2.3)

[3.2.4  Internal Definitions](book-Z-H-21.html#%_sec_3.2.4)

[3.3  Modeling with Mutable Data](book-Z-H-22.html#%_sec_3.3)

[3.3.1  Mutable List Structure](book-Z-H-22.html#%_sec_3.3.1)

[3.3.2  Representing Queues](book-Z-H-22.html#%_sec_3.3.2)

[3.3.3  Representing Tables](book-Z-H-22.html#%_sec_3.3.3)

[3.3.4  A Simulator for Digital Circuits](book-Z-H-22.html#%_sec_3.3.4)

[3.3.5  Propagation of Constraints](book-Z-H-22.html#%_sec_3.3.5)

[3.4  Concurrency: Time Is of the Essence](book-Z-H-23.html#%_sec_3.4)

[3.4.1  The Nature of Time in Concurrent
Systems](book-Z-H-23.html#%_sec_3.4.1)

[3.4.2  Mechanisms for Controlling
Concurrency](book-Z-H-23.html#%_sec_3.4.2)

[3.5  Streams](book-Z-H-24.html#%_sec_3.5)

[3.5.1  Streams Are Delayed Lists](book-Z-H-24.html#%_sec_3.5.1)

[3.5.2  Infinite Streams](book-Z-H-24.html#%_sec_3.5.2)

[3.5.3  Exploiting the Stream Paradigm](book-Z-H-24.html#%_sec_3.5.3)

[3.5.4  Streams and Delayed Evaluation](book-Z-H-24.html#%_sec_3.5.4)

[3.5.5  Modularity of Functional Programs and Modularity of
Objects](book-Z-H-24.html#%_sec_3.5.5)

### [4  Metalinguistic Abstraction](book-Z-H-25.html#%_chap_4)

[4.1  The Metacircular Evaluator](book-Z-H-26.html#%_sec_4.1)

[4.1.1  The Core of the Evaluator](book-Z-H-26.html#%_sec_4.1.1)

[4.1.2  Representing Expressions](book-Z-H-26.html#%_sec_4.1.2)

[4.1.3  Evaluator Data Structures](book-Z-H-26.html#%_sec_4.1.3)

[4.1.4  Running the Evaluator as a
Program](book-Z-H-26.html#%_sec_4.1.4)

[4.1.5  Data as Programs](book-Z-H-26.html#%_sec_4.1.5)

[4.1.6  Internal Definitions](book-Z-H-26.html#%_sec_4.1.6)

[4.1.7  Separating Syntactic Analysis from
Execution](book-Z-H-26.html#%_sec_4.1.7)

[4.2  Variations on a Scheme—Lazy
Evaluation](book-Z-H-27.html#%_sec_4.2)

[4.2.1  Normal Order and Applicative
Order](book-Z-H-27.html#%_sec_4.2.1)

[4.2.2  An Interpreter with Lazy
Evaluation](book-Z-H-27.html#%_sec_4.2.2)

[4.2.3  Streams as Lazy Lists](book-Z-H-27.html#%_sec_4.2.3)

[4.3  Variations on a Scheme—Nondeterministic
Computing](book-Z-H-28.html#%_sec_4.3)

[4.3.1  Amb and Search](book-Z-H-28.html#%_sec_4.3.1)

[4.3.2  Examples of Nondeterministic
Programs](book-Z-H-28.html#%_sec_4.3.2)

[4.3.3  Implementing the `Amb` Evaluator](book-Z-H-28.html#%_sec_4.3.3)

[4.4  Logic Programming](book-Z-H-29.html#%_sec_4.4)

[4.4.1  Deductive Information Retrieval](book-Z-H-29.html#%_sec_4.4.1)

[4.4.2  How the Query System Works](book-Z-H-29.html#%_sec_4.4.2)

[4.4.3  Is Logic Programming Mathematical
Logic?](book-Z-H-29.html#%_sec_4.4.3)

[4.4.4  Implementing the Query System](book-Z-H-29.html#%_sec_4.4.4)

### [5  Computing with Register Machines](book-Z-H-30.html#%_chap_5)

[5.1  Designing Register Machines](book-Z-H-31.html#%_sec_5.1)

[5.1.1  A Language for Describing Register
Machines](book-Z-H-31.html#%_sec_5.1.1)

[5.1.2  Abstraction in Machine Design](book-Z-H-31.html#%_sec_5.1.2)

[5.1.3  Subroutines](book-Z-H-31.html#%_sec_5.1.3)

[5.1.4  Using a Stack to Implement
Recursion](book-Z-H-31.html#%_sec_5.1.4)

[5.1.5  Instruction Summary](book-Z-H-31.html#%_sec_5.1.5)

[5.2  A Register-Machine Simulator](book-Z-H-32.html#%_sec_5.2)

[5.2.1  The Machine Model](book-Z-H-32.html#%_sec_5.2.1)

[5.2.2  The Assembler](book-Z-H-32.html#%_sec_5.2.2)

[5.2.3  Generating Execution Procedures for
Instructions](book-Z-H-32.html#%_sec_5.2.3)

[5.2.4  Monitoring Machine Performance](book-Z-H-32.html#%_sec_5.2.4)

[5.3  Storage Allocation and Garbage
Collection](book-Z-H-33.html#%_sec_5.3)

[5.3.1  Memory as Vectors](book-Z-H-33.html#%_sec_5.3.1)

[5.3.2  Maintaining the Illusion of Infinite
Memory](book-Z-H-33.html#%_sec_5.3.2)

[5.4  The Explicit-Control Evaluator](book-Z-H-34.html#%_sec_5.4)

[5.4.1  The Core of the Explicit-Control
Evaluator](book-Z-H-34.html#%_sec_5.4.1)

[5.4.2  Sequence Evaluation and Tail
Recursion](book-Z-H-34.html#%_sec_5.4.2)

[5.4.3  Conditionals, Assignments, and
Definitions](book-Z-H-34.html#%_sec_5.4.3)

[5.4.4  Running the Evaluator](book-Z-H-34.html#%_sec_5.4.4)

[5.5  Compilation](book-Z-H-35.html#%_sec_5.5)

[5.5.1  Structure of the Compiler](book-Z-H-35.html#%_sec_5.5.1)

[5.5.2  Compiling Expressions](book-Z-H-35.html#%_sec_5.5.2)

[5.5.3  Compiling Combinations](book-Z-H-35.html#%_sec_5.5.3)

[5.5.4  Combining Instruction Sequences](book-Z-H-35.html#%_sec_5.5.4)

[5.5.5  An Example of Compiled Code](book-Z-H-35.html#%_sec_5.5.5)

[5.5.6  Lexical Addressing](book-Z-H-35.html#%_sec_5.5.6)

[5.5.7  Interfacing Compiled Code to the
Evaluator](book-Z-H-35.html#%_sec_5.5.7)

------------------------------------------------------------------------

<div>

[References](book-Z-H-36.html#%_chap_Temp_849)

</div>

<div>

[List of Exercises](book-Z-H-37.html#%_chap_Temp_850)

</div>

<div>

<span
id="toc_chap_Temp_851">[Index](book-Z-H-38.html#%_chap_Temp_851)</span>

</div>

<div class="chapnav">

<span class="prev">Previous: [many kinds of
memory](./som-15.6.html)</span><span class="next">Next: [anatomy of
memory](./som-15.8.html)</span><span
class="contents">[Contents](index.html)</span>
<div class="titlebar">

Society of Mind
===============

</div>

</div>

*15.7* memory rearrangements
----------------------------

Let's return to moving mental furniture. What would we need to imagine
moving things around a room? First we'd need some way to represent how
objects are arranged in space. In our Block-Arch scenario, the scene was
represented in terms of the shapes of the objects and the relations
between them. In the case of a room scene, you might also relate each
object to the walls and corners of the room; you might notice that the
couch is about midway between a table and a chair, and that all three
are lined up near a certain wall.

Once we have a method for representing rooms, we also need techniques
for manipulating these representations. How could we envision the result
of exchanging that couch and chair? Let's oversimplify, and suppose that
this can he done simply by exchanging the states of two agencies â€” an
agency A, which represents the couch, and another agency B, which
represents the chair. To exchange these states, let's assume that both
agencies have access to two *short-term memory-units,* called M-1 and
M-2, which can record the states of agencies. Then we can exchange the
states of A and B, first by storing away the states A and B, and then by
restoring them in reverse order. In other words, we could use the
following simple four-step *script*:

1\. Store the state of A in M-1. 2. Store the state of B in M-2. 3. Use
M-2 to determine the state of A. 4. Use M-1 to determine the state of B.

A *memory-control script* like this can work only if we have
memory-units that are small enough to pick out couch-sized portions of
the larger scene. M-1 and M-2 would not do the job if they could store
only descriptions of entire rooms. In other words, we have to be able to
connect our short-term memories only to appropriate aspects of our
current problems. Learning such abilities is not simple, and perhaps it
is a skill some people never really master. What if we wanted to
rearrange three or more objects? As a matter of fact, it is possible to
produce any rearrangement whatsoever, using only operations that
exchange two objects at a time! When you approach an unfamiliar kind of
problem, it's best to start by making only one or two changes at a time.
Then, in the course of becoming an expert, you discover schemes that
make several useful changes in memory at once.

Our pair-exchanging script needs more machinery. Because each
memory-unit must wait until the previous step is finished, the timing of
each script step may have to depend on various *condition sensors.*
Shortly we'll see that even this is not enough to solve hard problems:
our memory-control processes also need ways to interrupt themselves
while they call on other agencies or memories for help. Indeed, the
problems we must solve when managing our memories are surprisingly like
those we face when dealing with things in the outside world.

<div class="footer">

[![Creative Commons
License](http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png)](http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\
\
[![](./images/som_book.jpeg){#book}
![](./images/a_logo_17.gif)](http://www.amazon.com/gp/product/0671657135?ie=UTF8&camp=1789&creativeASIN=0671657135&linkCode=xm2&tag=marvinminsky)

</div>

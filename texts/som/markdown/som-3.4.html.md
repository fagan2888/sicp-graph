<div class="chapnav">

<span class="prev">Previous: [hierarchies](./som-3.3.html)</span><span
class="next">Next: [destructiveness](./som-3.5.html)</span><span
class="contents">[Contents](index.html)</span>
<div class="titlebar">

Society of Mind
===============

</div>

</div>

*3.4* Heterarchies
------------------

A hierarchical society is like a tree in which the agent at each branch
is exclusively responsible for the agents on the twigs that branch from
it. This pattern is found in every field, because dividing work into
parts like that is usually the easiest way to start solving a problem.
It is easy to construct and understand such organizations because each
agent has only a single job to do: it needs only to *look up* for
instructions from its supervisor, then *look down* to get help from its
subordinates.

But hierarchies do not always work. Consider that when two agents need
to use each other's skills, then neither one can be *on top.* Notice
what happens, for example, when you ask your vision-system to decide
whether the following left-side scene depicts three blocks — or only
two.

![](./illus/ch3/3-3.png){.illus}

The agent See could answer that if it could Move the front block out of
the line of view. But, in the course of doing that, Move might have to
See if there were any obstacles that might interfere with the arm's
trajectory. At such a moment, Move would be working for See, and See
would be working for Move, both at the same time. This would be
impossible inside a simple hierarchy.

Most of the diagrams in the early parts of this book depict simple
hierarchies. Later, we'll see more cross-connected rings and loops —
when we are forced to consider the need for memory, which will become a
constant subject of concern in this book. People often think of memory
in terms of keeping records of the past, for recollecting things that
happened in earlier times. But agencies also need other kinds of memory
as well. See, for example, requires some sort of temporary memory in
order to keep track of what next to do, when it starts one job before
its previous job is done. If each of See's agents could do only one
thing at a time, it would soon run out of resources and be unable to
solve complicated problems. But if we have enough memory, we can arrange
our agents into circular loops and thus use the same agents over and
over again to do parts of several different jobs at the same time.

<div class="footer">

[![Creative Commons
License](http://i.creativecommons.org/l/by-nc-sa/3.0/80x15.png)](http://creativecommons.org/licenses/by-nc-sa/3.0/deed.en_US)\
\
[![](./images/som_book.jpeg){#book}
![](./images/a_logo_17.gif)](http://www.amazon.com/gp/product/0671657135?ie=UTF8&camp=1789&creativeASIN=0671657135&linkCode=xm2&tag=marvinminsky)

</div>
